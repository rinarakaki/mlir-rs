//! Base Pattern Definition File
//!
//! This files contains all of the base constructs for defining DRR patterns.
//!
//! - include <https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/PatternBase.td>


/**
Base class for op+ -> op+ rewrite rules. These allow declaratively specifying rewrite rules.

A rewrite rule contains two components: a source pattern and one or more result patterns. Each pattern is specified as a (recursive) DAG node (tree) in the form of `(node arg0, arg1, ...)`.

The `node` are normally MLIR ops, but it can also be one of the directives listed later in this section.

## Symbol binding

In the source pattern, `argN` can be used to specify matchers (e.g., using type/attribute type constraints, etc.) and bound to a name for later use.
We can also bind names to op instances to reference them later in multi-entity constraints. Operands in the source pattern can have the same name. This bounds one operand to the name while verifying the rest are all equal.

In the result pattern, `argN` can be used to refer to a previously bound name, with potential transformations (e.g., using tAttr, etc.). `argN` can itself be nested DAG node. We can also bound names to ops to reference them later in other result patterns.

For example,

```
def : Pattern<(OneResultOp1:$op1 $arg0, $arg1, $arg0),
              [(OneResultOp2:$op2 $arg0, $arg1),
               (OneResultOp3 $op2 (OneResultOp4))],
              [(HasStaticShapePred $op1)]>;
```

First `$arg0` and '$arg1' are bound to the `OneResultOp1`'s first and second arguments and used later to build `OneResultOp2`. Second '$arg0' is verified to be equal to the first '$arg0' operand.
`$op1` is bound to `OneResultOp1` and used to check whether the result's shape is static. `$op2` is bound to `OneResultOp2` and used to build `OneResultOp3`.

## Multi-result op

To create multi-result ops in result pattern, you can use a syntax similar to uni-result op, and it will act as a value pack for all results:

```
def : Pattern<(ThreeResultOp ...),
              [(TwoResultOp ...), (OneResultOp ...)]>;
```

Then `TwoResultOp` will replace the first two values of `ThreeResultOp`.

You can also use `$<name>__N` to explicitly access the N-th result.

```
def : Pattern<(FiveResultOp ...),
              [(TwoResultOp1:$res1__1 ...), (replaceWithValue $res1__0),
               (TwoResultOp2:$res2 ...), (replaceWithValue $res2__1)]>;
```

Then the values generated by `FiveResultOp` will be replaced by

- `FiveResultOp`#0: `TwoResultOp1`#1
- `FiveResultOp`#1: `TwoResultOp1`#0
- `FiveResultOp`#2: `TwoResultOp2`#0
- `FiveResultOp`#3: `TwoResultOp2`#1
- `FiveResultOp`#4: `TwoResultOp2`#1
*/
pub struct Pattern<
    source: dag,
    results: list<dag>,
    preds: list<dag> = [],
    dag benefit_added = (addBenefit 0)> {
    dag sourcePattern = source;
    /// Result patterns. Each result pattern is expected to replace one result
    /// of the root op in the source pattern. In the case of more result patterns
    /// than needed to replace the source op, only the last N results generated
    /// by the last N result pattern is used to replace a N-result source op.
    /// So that the beginning result patterns can be used to generate additional
    /// ops to aid building the results used for replacement.
    list<dag> result_patterns = results;
    /// Multi-entity constraints. Each constraint here involves multiple entities
    /// matched in source pattern and places further constraints on them as a
    /// whole.
    list<dag> constraints = preds;
    /// The delta value added to the default benefit value. The default value is
    /// the number of ops in the source pattern. The rule with the highest final
    /// benefit value will be applied first if there are multiple rules matches.
    /// This delta value can be either positive or negative.
    dag benefit_delta = benefitAdded;
}
